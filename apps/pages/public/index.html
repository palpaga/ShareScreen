<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ShareScreen</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <link rel="stylesheet" href="style.css">
</head>

<body class="beams">
  <div class="container" id="landing" role="main">
    <div class="hero" aria-labelledby="t-title" aria-describedby="t-sub">
      <div class="brand">
        <span class="dot" aria-hidden="true"></span>
        <span class="name">ShareScreen.live</span>
      </div>
      <h1 id="t-title"></h1>

      <p class="lead" id="t-sub"></p>

      <div class="cta" aria-live="polite">
        <button class="btn btn-primary btn-fullwidth" id="btnHost">
          🚀 <span id="t-start"></span>
        </button>

        <div class="join-inline" style="margin-top:6px">
          <input id="joinId" class="input" placeholder="Ex. abc123" maxlength="16" inputmode="latin"
            title="3–64 lettres/chiffres/_-" />
          <button class="btn btn-secondary" id="btnJoin">
            <span id="t-join"></span>
          </button>
        </div>

      </div>

      <footer id="site-footer">
        <div id="t-footer"></div>
        <div class="lang">
          <label for="langSel" id="t-lang-label"></label>
          <select id="langSel" aria-label="Language">
            <option value="fr">Français</option>
            <option value="en">English</option>
          </select>
        </div>
      </footer>
    </div>
  </div>

  <!-- Stage fullscreen -->
  <div class="stage" id="stage" aria-hidden="true">
    <video id="video" autoplay playsinline></video>
    <div class="hud" aria-hidden="false">
      <div class="hud-top">
        <span class="pill" id="statusPill">⏳ <span id="statusText"></span></span>
        <span class="pill" id="rolePill">—</span>
        <span class="pill" id="viewersPill" style="display:none">👥 <span id="viewerCount">0</span></span>
        <span class="pill" id="statsPill" title="Stats vidéo" style="display:none">📊 <span
            id="statsText">—</span></span>
        <div class="hud-right">
          <span class="pill copy" id="copyWrap" style="display:none">
            🔗 <input class="input" id="publicLink" readonly>
            <button class="btn btn-secondary" id="btnCopy"></button>
          </span>
        </div>
      </div>

      <div class="quit"><button class="btn-quit" id="btnQuitTop">✖</button></div>

      <div class="hud-bottom">
        <div class="left-controls">
          <div class="vol" id="volWrap" style="display:none">
            <label for="volume" id="t-volume"></label>
            <input id="volume" class="slider" type="range" min="0" max="100" value="0">
          </div>
          <button class="btn btn-secondary" id="btnLogs" title="Logs" aria-label="Logs">🧾</button>
        </div>
        <div class="right-controls">
          <button class="btn btn-secondary" id="btnFullscreen" title="Plein écran (f)">⛶</button>
        </div>
      </div>
      <div class="logs" id="logs"></div>
    </div>
  </div>

  <!-- i18n + UI wiring -->
  <script src="i18n.js"></script>

  <script>
    (function () {
      const $ = (sel) => document.querySelector(sel);
      const logBox = $('#logs');
      function log(msg, cls = '') {
        const line = document.createElement('div');
        line.className = 'log-line';
        line.innerHTML = cls ? `<span class="${cls}">${msg}</span>` : msg;
        logBox.appendChild(line);
        logBox.scrollTop = logBox.scrollHeight;
        console.debug('[LOG]', msg);
      }

      const stage = $('#stage');
      const videoEl = $('#video');
      const statusText = $('#statusText');
      const rolePill = $('#rolePill');
      const viewersPill = $('#viewersPill');
      const statsPill = $('#statsPill');
      const statsText = $('#statsText');
      const viewerCountEl = $('#viewerCount');
      const copyWrap = $('#copyWrap');
      const publicLink = $('#publicLink');
      const volWrap = $('#volWrap');
      const volumeSlider = $('#volume');

      function setStatus(t, good = false) {
        statusText.textContent = t;
        const p = $('#statusPill');
        if (good) p.classList.add('badge'); else p.classList.remove('badge');
        log(t, good ? 'ok' : '');
      }

      async function withWakeLock(enabled) {
        try {
          if (!('wakeLock' in navigator)) return;
          if (enabled) window.__wl = await navigator.wakeLock.request('screen');
          else { await window.__wl?.release(); window.__wl = null; }
        } catch { }
      }

      async function toggleFullscreen() {
        try { await (document.fullscreenElement ? document.exitFullscreen() : stage.requestFullscreen()); } catch { }
      }

      const url = new URL(location.href);
      const hardcodedTurn = url.searchParams.get('mode') === 'hardcoded';

      /** @type {WebSocket|null} */
      let ws = null;
      let room = '';
      let role = 'none';

      function wsUrl(path = '/ws') {
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        return `${proto}://${location.host}${path}?room=${encodeURIComponent(room)}&role=${role}`;
      }
      function wsSend(obj) { try { if (ws && ws.readyState === 1) ws.send(JSON.stringify(obj)); } catch { } }

      async function getIceServers() {
        if (hardcodedTurn) return [{ urls: [] }];
        const r = await fetch('/config', { cache: 'no-store' });
        const j = await r.json();
        return j.iceServers ?? [];
      }

      // ===== Stats (viewer)
      let statsTimer = null; let lastBytes = 0; let lastTs = 0;
      function startStatsLoop(pc) {
        statsPill.style.display = 'inline-flex';
        clearInterval(statsTimer);
        statsTimer = setInterval(async () => {
          try {
            const report = await pc.getStats();
            let fps = null; let w = videoEl.videoWidth || 0; let h = videoEl.videoHeight || 0; let bytes = null;
            report.forEach((s) => { if (s.type === 'inbound-rtp' && s.kind === 'video') { fps = s.framesPerSecond ?? fps; bytes = s.bytesReceived ?? bytes; } });
            const now = performance.now();
            let kbps = null;
            if (bytes != null) {
              if (lastTs) {
                const deltaB = bytes - lastBytes; const deltaT = (now - lastTs) / 1000;
                if (deltaT > 0) kbps = Math.max(0, (deltaB * 8 / 1000) / deltaT) | 0;
              }
              lastBytes = bytes; lastTs = now;
            }
            const parts = [];
            if (w && h) parts.push(`${w}×${h}`);
            if (typeof fps === 'number') parts.push(`${fps | 0} fps`);
            if (kbps != null) parts.push(`${kbps} kbps`);
            statsText.textContent = parts.join(' · ') || '—';
          } catch { }
        }, 1000);
      }
      function stopStatsLoop() { clearInterval(statsTimer); statsTimer = null; statsText.textContent = '—'; statsPill.style.display = 'none'; }

      // ===== Host
      const peers = new Map();
      let screenStream = null, iceServers = [], viewerCount = 0;

      function newPeer(viewerId) {
        const pc = new RTCPeerConnection({ iceServers });
        let negotiating = false;

        async function renegotiate() {
          if (negotiating) return; negotiating = true;
          try {
            const offer = await pc.createOffer({ offerToReceiveVideo: false });
            await pc.setLocalDescription(offer);
            wsSend({ type: 'signal', target: viewerId, data: { sdp: pc.localDescription } });
          } catch (e) { log('renegotiate error: ' + e.message, 'err'); }
          finally { negotiating = false; }
        }

        pc.onnegotiationneeded = () => { void renegotiate(); };
        pc.onicecandidate = (e) => { if (e.candidate) wsSend({ type: 'signal', target: viewerId, data: { candidate: e.candidate } }); };
        pc.addEventListener('icegatheringstatechange', () => log(`gathering(${viewerId}): ${pc.iceGatheringState}`));
        pc.addEventListener('iceconnectionstatechange', () => {
          log(`ICE(${viewerId}): ${pc.iceConnectionState}`);
          if (['connected', 'completed'].includes(pc.iceConnectionState)) {
            pc.getStats().then(r => r.forEach(s => {
              if (s.type === 'candidate-pair' && s.nominated && s.state === 'succeeded') {
                log(`✅ Pair ${viewerId}: ${s.localCandidateId} ⇄ ${s.remoteCandidateId}`, 'ok');
              }
            }));
          }
        });
        if (screenStream) { screenStream.getTracks().forEach(t => pc.addTrack(t, screenStream)); }
        return pc;
      }

      async function startHost() {
        role = 'host';
        rolePill.textContent = window.i18n.t('role_host');

        room = (location.hash.slice(1) || Math.random().toString(36).slice(2, 10));
        if (!location.hash) location.hash = room;
        const origin = window.location.origin; publicLink.value = `${origin}${location.pathname}#${room}`;

        iceServers = await getIceServers(); log('ICE servers: ' + JSON.stringify(iceServers));

        $('#landing').style.display = 'none'; stage.classList.add('active'); viewersPill.style.display = 'inline-flex'; copyWrap.style.display = 'inline-flex';
        videoEl.muted = true; volWrap.style.display = 'none';
        setStatus(window.i18n.t('status_wait_share'));

        try {
          screenStream = await navigator.mediaDevices.getDisplayMedia({ video: { frameRate: 30 }, audio: true });
          if (!screenStream.getAudioTracks().length) {
            try { const mic = await navigator.mediaDevices.getUserMedia({ audio: true }); mic.getTracks().forEach(t => screenStream.addTrack(t)); } catch { }
          }
          videoEl.srcObject = screenStream;
          try { await videoEl.play(); } catch { }
          setStatus(window.i18n.t('status_started'), true);
          screenStream.getVideoTracks()[0].addEventListener('ended', endAll);
        } catch (e) { setStatus('Capture refusée: ' + e.message); return; }

        ws = new WebSocket(wsUrl());
        ws.onopen = () => log('websocket connected (host)', 'ok');
        ws.onclose = () => log('websocket closed (host)', 'warn');
        ws.onerror = () => log('websocket error (host)', 'err');
        ws.onmessage = async (ev) => {
          let msg; try { msg = JSON.parse(ev.data); } catch { return; }
          if (!msg || typeof msg !== 'object') return;

          if (msg.type === 'viewer-count' && msg.data && typeof msg.data.viewerCount === 'number') {
            viewerCount = msg.data.viewerCount; viewerCountEl.textContent = String(viewerCount);
            return;
          }
          if (msg.type === 'viewer-joined' && msg.viewerId) {
            const viewerId = msg.viewerId;
            log('👤 Viewer joined: ' + viewerId);

            if (!peers.has(viewerId)) peers.set(viewerId, newPeer(viewerId));
            const pc = peers.get(viewerId);

            (async () => {
              try {
                const offer = await pc.createOffer({ offerToReceiveVideo: false });
                await pc.setLocalDescription(offer);
                wsSend({ type: 'signal', target: viewerId, data: { sdp: pc.localDescription } });
                log(`➡️ Sent offer to ${viewerId}`);
              } catch (e) { log('offer error: ' + e.message, 'err'); }
            })();

            return;
          }
          if (msg.type === 'signal' && msg.from) {
            const viewerId = msg.from;
            if (!peers.has(viewerId)) peers.set(viewerId, newPeer(viewerId));
            const pc = peers.get(viewerId);

            const { data } = msg;
            if (data?.sdp) {
              await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            } else if (data?.candidate) {
              try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); } catch { }
            }
          }
        };

        await withWakeLock(true);
      }

      function endAll() {
        try { document.exitFullscreen?.(); } catch { }
        withWakeLock(false);
        stopStatsLoop();
        if (screenStream) { screenStream.getTracks().forEach(t => t.stop()); screenStream = null; }
        for (const pc of peers.values()) try { pc.close(); } catch { }
        peers.clear();
        try { ws?.close(); } catch { }
        ws = null;
        videoEl.srcObject = null;
        viewerCount = 0; viewerCountEl.textContent = '0';
        stage.classList.remove('active'); $('#landing').style.display = '';
        setStatus(window.i18n.t('status_session_end'));
      }

      // ===== Viewer
      let vPc = null, vIceServers = [], currentHostId = null;

      async function ensureViewerPC() {
        if (vPc) return vPc;
        vPc = new RTCPeerConnection({ iceServers: vIceServers });
        vPc.onicecandidate = (e) => { if (e.candidate && currentHostId) wsSend({ type: 'signal', target: currentHostId, data: { candidate: e.candidate } }); };
        vPc.addEventListener('icegatheringstatechange', () => log('gathering(viewer): ' + vPc.iceGatheringState));
        vPc.addEventListener('iceconnectionstatechange', () => {
          log('ICE(viewer): ' + vPc.iceConnectionState);
          if (vPc.iceConnectionState === 'failed') setStatus(window.i18n.t('status_conn_failed'));
          if (['connected', 'completed'].includes(vPc.iceConnectionState)) {
            vPc.getStats().then(r => r.forEach(s => {
              if (s.type === 'candidate-pair' && s.nominated && s.state === 'succeeded') {
                log('✅ Pair (viewer): ' + s.localCandidateId + ' ⇄ ' + s.remoteCandidateId, 'ok');
              }
            }));
          }
        });
        try { vPc.addTransceiver('video', { direction: 'recvonly' }); } catch { }
        vPc.ontrack = async (ev) => {
          videoEl.srcObject = ev.streams[0];
          videoEl.muted = true;
          volWrap.style.display = 'flex';
          try { await videoEl.play(); } catch (e) { console.debug('play blocked', e?.message); }
          setStatus(window.i18n.t('status_streaming'), true);
          startStatsLoop(vPc);
        };
        return vPc;
      }

      async function startViewer() {
        role = 'viewer';
        rolePill.textContent = window.i18n.t('role_viewer');

        const manual = ($('#joinId').value || '').trim() || location.hash.slice(1);
        const sane = (manual || '').replace(/[^a-zA-Z0-9_-]/g, '').slice(0, 64);
        if (!sane || sane.length < 3) { alert(window.i18n.t('invalidId')); return; }
        location.hash = sane;
        room = sane;

        vIceServers = await getIceServers(); log('ICE servers: ' + JSON.stringify(vIceServers));

        $('#landing').style.display = 'none'; stage.classList.add('active'); viewersPill.style.display = 'inline-flex'; copyWrap.style.display = 'none';
        videoEl.muted = false;
        setStatus(window.i18n.t('status_conn'));

        ws = new WebSocket(wsUrl());
        ws.onopen = () => log('websocket connected (viewer)', 'ok');
        ws.onclose = () => { log('websocket closed (viewer)', 'warn'); };
        ws.onerror = () => log('websocket error (viewer)', 'err');
        ws.onmessage = async (ev) => {
          let msg; try { msg = JSON.parse(ev.data); } catch { return; }
          if (!msg || typeof msg !== 'object') return;

          if (msg.type === 'host-left') {
            setStatus(window.i18n.t('status_host_left'));
            if (vPc) { vPc.close(); vPc = null; }
            videoEl.srcObject = null;
            stopStatsLoop();
            return;
          }
          if (msg.type === 'viewer-count' && msg.data && typeof msg.data.viewerCount === 'number') {
            viewerCountEl.textContent = String(msg.data.viewerCount);
            return;
          }
          if (msg.type === 'signal' && msg.from === 'host') {
            const pc = await ensureViewerPC();
            const { data } = msg;
            if (data?.sdp && data.sdp.type === 'offer') {
              await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              currentHostId = 'host';
              wsSend({ type: 'signal', target: 'host', data: { sdp: pc.localDescription } });
              setStatus(window.i18n.t('status_negotiating'));
            } else if (data?.candidate) {
              try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); } catch { }
            }
            return;
          }
        };
      }

      function endViewer() {
        try { document.exitFullscreen?.(); } catch { }
        if (vPc) { try { vPc.close(); } catch { } vPc = null; }
        try { ws?.close(); } catch { }
        ws = null;
        stopStatsLoop();
        videoEl.srcObject = null;
        stage.classList.remove('active'); $('#landing').style.display = '';
        setStatus(window.i18n.t('status_session_quit'));
      }

      // Wire UI
      $('#btnHost').addEventListener('click', startHost);
      $('#btnJoin').addEventListener('click', startViewer);
      $('#btnLogs').addEventListener('click', () => logBox.classList.toggle('active'));
      $('#btnFullscreen').addEventListener('click', toggleFullscreen);
      $('#btnQuitTop').addEventListener('click', () => { role === 'host' ? endAll() : endViewer(); });
      $('#btnCopy').addEventListener('click', async () => {
        try { await navigator.clipboard.writeText(publicLink.value); } catch (e) { setStatus(window.i18n.t('status_copy_fail') + ': ' + e.message); }
      });

      if (volumeSlider) {
        volumeSlider.addEventListener('input', () => {
          const v = Math.max(0, Math.min(1, volumeSlider.value / 100));
          videoEl.volume = v;
          videoEl.muted = v === 0 ? true : false;
        });
      }

      const h = location.hash.slice(1);
      if (h) {
        const j = $('#joinId');
        if (j) j.value = h;
        setTimeout(() => { startViewer(); }, 200);
      }

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') { role === 'host' ? endAll() : endViewer(); }
      });
    })();
  </script>
</body>

</html>
